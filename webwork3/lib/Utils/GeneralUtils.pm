package Utils::GeneralUtils;
use base qw(Exporter);

### this is a number of subrotines from the webwork2 version of WeBWorK::Utils

use Dancer ':syntax';
use strict;
use warnings;
use DateTime;
use DateTime::TimeZone;

our @EXPORT    = ();

our @EXPORT_OK = qw(timeToUTC timeFromUTC writeConfigToFile getCourseSettingsWW2);


################################################################################
# Date/time processing
################################################################################

=head2 Date/time processing

=over

=item $dateTime = timeToUTC($time_as_epoch, $tz_name)

This shifts the date/time $datetime (as a epoch) from the timezone: $tz_name to UTC. 
This should be called after a date/time is read from the DB and before sent to the client.  

=cut

sub timeToUTC {
    my ($time_as_epoch,$tz_name) = @_;

    $tz_name ||= "local";  # use the timezone local to the server if no timezone is set. 
    if(!DateTime::TimeZone->is_valid_name($tz_name)){
        warn qq! $tz_name is not a legal time zone name. Fix it on the Course Configuration page. 
	      <a href="http://en.wikipedia.org/wiki/List_of_zoneinfo_time_zones">View list of time zones.</a> \n!;
	    $tz_name = "America/New_York";
    }
    
    my $utc = DateTime::TimeZone->new( name => $tz_name);
    my $dt = DateTime->from_epoch(epoch=>$time_as_epoch,time_zone=>"UTC");
    $dt->subtract(seconds=>$utc->offset_for_datetime($dt)); 
    return $dt->epoch;

}

=item $dateTime = timeFromUTC($time_as_epch,$tz_name)

 This shifts the date/time $datetime (as a epoch) from the timezone in $timezone to UTC.  This should be called
 after a date/time is returned from the client and before it is written to the DB. 


=cut

sub timeFromUTC {
    my ($dateTime,$tz_name) = @_;
    
    $tz_name ||= "local";  # use the timezone local to the server if no timezone is set. 
    if(!DateTime::TimeZone->is_valid_name($tz_name)){
        warn qq! $tz_name is not a legal time zone name. Fix it on the Course Configuration page. 
	      <a href="http://en.wikipedia.org/wiki/List_of_zoneinfo_time_zones">View list of time zones.</a> \n!;
	    $tz_name = "America/New_York";
    }
    my $tz = DateTime::TimeZone->new( name => $tz_name );
    my $dt = DateTime->from_epoch(epoch=>$dateTime,time_zone =>"UTC");  # This is the datetime object in the timezone $timezone. 
    $dt->add(seconds => $tz->offset_for_datetime($dt));

    return $dt->epoch;
}



# the following are used for loading settings in the WW2 way.  
# we should change the settings so they are stored as a JSON file instead.  This
# eliminate the need for these subroutines.  

### pstaab: I think a nearly identical version of this is in Utils::CourseUtils

sub getCourseSettingsWW2 {
    my $ce = shift; 

	my $ConfigValues = $ce->{ConfigValues};

	# get the list of theme folders in the theme directory and remove . and ..
	my $themeDir = $ce->{webworkDirs}{themes};
	opendir(my $dh, $themeDir) || die "can't opendir $themeDir: $!";
	my $themes =[grep {!/^\.{1,2}$/} sort readdir($dh)];


	foreach my $oneConfig (@$ConfigValues) {
		foreach my $hash (@$oneConfig) {
			if (ref($hash) eq "HASH") {
				my $string = $hash->{var};
				if ($string =~ m/^\w+$/) {
					$string =~ s/^(\w+)$/\{$1\}/;
				} else {
					$string =~ s/^(\w+)/\{$1\}->/;
				}
				$hash->{value} = eval('$ce->' . $string);

				if ($hash->{var} eq 'defaultTheme'){
					$hash->{values} = $themes;	
				}
			}
		}
	}


	my $tz = DateTime::TimeZone->new( name => $ce->{siteDefaults}->{timezone}); 
	my $dt = DateTime->now();

	my @tzabbr = ("tz_abbr", $tz->short_name_for_datetime( $dt ));

	push(@$ConfigValues, \@tzabbr);

	return $ConfigValues;
}



sub writeConfigToFile {

	my ($ce,$config) = @_;

	my $filename = $ce->{courseDirs}->{root} . "/simple.conf";

		my $fileoutput = "#!perl
# This file is automatically generated by WeBWorK's web-based
# configuration module.  Do not make changes directly to this
# file.  It will be overwritten the next time configuration
# changes are saved.\n\n";


	# read in the file 

	my @raw_data =();
	if (-e $filename){
		open(DAT, $filename) || die("Could not open file!");
		@raw_data=<DAT>;
		close(DAT);
	} 

	my $line;
	my $varFound = 0; 

	foreach $line (@raw_data)
	{
		chomp $line;
	 	if ($line =~ /^\$/) {
	 		my ($var,$value) = ($line =~ /^\$(.*)\s+=\s+(.*);$/);
	 		if ($var eq $config->{var}){ 
	 			$fileoutput .= writeLine($config->{var},$config->{value});
	 			$varFound = 1; 
	 		} else {
	 			$fileoutput .= writeLine($var,$value);
	 		}
		}
	}

	if (! $varFound) {
		$fileoutput .= writeLine($config->{var},$config->{value});
	}

	my $writeFileErrors;
	eval {                                                          
		local *OUTPUTFILE;
		if( open OUTPUTFILE, ">", $filename) {
			print OUTPUTFILE $fileoutput;
			close OUTPUTFILE;
		} else {
			$writeFileErrors = "I could not open $fileoutput".
				"We will not be able to make configuration changes unless the permissions are set so that the web server can write to this file.";
		}
	};  # any errors are caught in the next block

	$writeFileErrors = $@ if $@;

	if ($writeFileErrors){
		return {error=>$writeFileErrors};
	} else {
		if($config->{type} eq 'boolean'){
			$config->{value} = $config->{value} ? JSON::true : JSON::false;
		}
		return $config;
	}
}

sub writeLine {
	my ($var,$value) = @_;
	my $val = (ref($value) =~/ARRAY/) ? to_json($value,{pretty=>0}): $value;
	$val = "'".$val . "'" if ($val =~ /^[\w\s\/]+$/);
	#$val =~ s/'//g;
	return "\$" . $var . " = " . $val . ";\n";
}




1;